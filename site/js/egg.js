// Generated by CoffeeScript 2.3.2
(function() {
  var Application, Camera, Geometry, Renderer, main;

  Renderer = class Renderer {
    constructor(canvasId, ...shaderIds) {
      var canvas, getShaderById, gl, i, id, len, shader, shaderProgram;
      this.update = this.update.bind(this);
      canvas = document.querySelector(canvasId);
      if (!canvas) {
        throw `Could not find canvas with id = \`${id}\``;
      }
      gl = canvas.getContext("webgl");
      if (!gl) {
        throw `Could not initialise WebGL for canvas with id = \`${id}\``;
      }
      getShaderById = (function() {
        var types;
        types = {
          "x-shader/x-vertex": gl.VERTEX_SHADER,
          "x-shader/x-fragment": gl.FRAGMENT_SHADER
        };
        return function(id) {
          var element, error, shader, type, type_attr;
          element = document.getElementById(id);
          if (!element) {
            throw `could not load shader \`${id}\``;
          }
          type_attr = element.getAttribute("type");
          type = types[type_attr];
          if (types == null) {
            throw `unknown type \`${type_attr}\` for shader \`${id}\``;
          }
          shader = gl.createShader(type);
          gl.shaderSource(shader, element.text);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            error = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw `while compiling shader \`${id}\`: ${error}`;
          }
          return shader;
        };
      })();
      shaderProgram = gl.createProgram();
      for (i = 0, len = shaderIds.length; i < len; i++) {
        id = shaderIds[i];
        shader = getShaderById(id);
        gl.attachShader(shaderProgram, shader);
      }
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        throw "Could not link shaders";
      }
      gl.useProgram(shaderProgram);
      shaderProgram.location = {
        vertex: gl.getAttribLocation(shaderProgram, "vertex"),
        projection: gl.getUniformLocation(shaderProgram, "projection"),
        view: gl.getUniformLocation(shaderProgram, "view")
      };
      gl.clearColor(0.5, 0.5, 0.5, 0.9);
      gl.enable(gl.DEPTH_TEST);
      gl.viewport(0, 0, canvas.width, canvas.height);
      [this.canvas, this.gl, this.shaderProgram] = [canvas, gl, shaderProgram];
    }

    update(geometry) {
      var gl, indices;
      gl = this.gl;
      gl.clear(gl.COLOR_BUFFER_BIT);
      indices = geometry.buffers.indices;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);
      return gl.drawElements(gl.TRIANGLES, geometry.size, gl.UNSIGNED_SHORT, 0);
    }

  };

  Camera = class Camera {
    constructor(renderer1, kwargs) {
      var aspect, canvas, far, fov, near, position, rotation;
      this.update = this.update.bind(this);
      this.renderer = renderer1;
      canvas = this.renderer.canvas;
      if (kwargs != null) {
        ({fov, aspect, near, far, position, rotation} = kwargs);
      }
      if (fov == null) {
        fov = 45 * Math.PI / 180;
      }
      if (aspect == null) {
        aspect = canvas.width / canvas.height;
      }
      if (near == null) {
        near = 0.1;
      }
      if (far == null) {
        far = 100;
      }
      this.projection = glMatrix.mat4.create();
      glMatrix.mat4.perspective(this.projection, fov, aspect, near, far);
      this.view = glMatrix.mat4.create();
      if (position != null) {
        this.translate(...position);
      }
      this.update();
    }

    update() {
      var gl, shaderProgram;
      [gl, shaderProgram] = [this.renderer.gl, this.renderer.shaderProgram];
      gl.uniformMatrix4fv(shaderProgram.location.projection, false, this.projection);
      return gl.uniformMatrix4fv(shaderProgram.location.view, false, this.view);
    }

    translate(x, y, z) {
      return glMatrix.mat4.translate(this.view, this.view, [x, y, z]);
    }

  };

  Geometry = class Geometry {
    constructor(renderer, vertices, indices) {
      var gl, indexBuffer, shaderProgram, vertexBuffer;
      [gl, shaderProgram] = [renderer.gl, renderer.shaderProgram];
      // Create and fill the vertex buffer
      vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.vertexAttribPointer(shaderProgram.location.vertex, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(shaderProgram.location.vertex);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      // Create and fill the index buffer
      indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      this.buffers = {
        vertices: vertexBuffer,
        indices: indexBuffer
      };
      this.size = indices.length;
    }

  };

  Application = class Application {
    constructor(renderer1, geometry1, camera1) {
      var scope;
      this.run = this.run.bind(this);
      this.keyDown = this.keyDown.bind(this);
      this.keyUp = this.keyUp.bind(this);
      this.renderer = renderer1;
      this.geometry = geometry1;
      this.camera = camera1;
      this.walkspeed = 1.0;
      scope = this;
      this._keyMap = {
        KeyA: function(state) {
          return scope._moveLeft = state;
        },
        KeyW: function(state) {
          return scope._moveForward = state;
        },
        KeyD: function(state) {
          return scope._moveRight = state;
        },
        KeyS: function(state) {
          return scope._moveBackward = state;
        },
        KeyQ: function(state) {
          return scope._moveDown = state;
        },
        KeyE: function(state) {
          return scope._moveUp = state;
        },
        KeyX: function(state) {
          return scope._toggleView = state;
        }
      };
      window.addEventListener("keydown", this.keyDown, false);
      window.addEventListener("keyup", this.keyUp, false);
    }

    run() {
      var animate, t0;
      t0 = 0;
      animate = (time) => {
        var dX, dY, dZ, delta;
        delta = (time - t0) * 1e-03 * this.walkspeed;
        t0 = time;
        if (this._moveLeft && !this._moveRight) {
          dX = -1;
        } else if (this._moveRight && !this._moveLeft) {
          dX = 1;
        } else {
          dX = 0;
        }
        if (this._moveForward && !this._moveBackward) {
          dZ = 1;
        } else if (this._moveBackward && !this._moveForward) {
          dZ = -1;
        } else {
          dZ = 0;
        }
        if (this._moveUp && !this._moveDown) {
          dY = 1;
        } else if (this._moveDown && !this._moveUp) {
          dY = -1;
        } else {
          dY = 0;
        }
        if ((dX !== 0) || (dY !== 0) || (dZ !== 0)) {
          this.camera.translate(delta * dX, delta * dY, delta * dZ);
          this.camera.update();
          this.renderer.update(this.geometry);
        }
        return window.requestAnimationFrame(animate);
      };
      this.renderer.update(this.geometry);
      return animate(0);
    }

    keyDown(event) {
      var action;
      action = this._keyMap[event.code];
      if (action != null) {
        return action(true);
      }
    }

    keyUp(event) {
      var action;
      action = this._keyMap[event.code];
      if (action != null) {
        return action(false);
      }
    }

  };

  main = function() {
    var app, camera, canvas, geometry, gl, indices, r, shaderProgram, vertices;
    r = new Renderer("#glCanvas", "egg-vs", "egg-fs");
    [canvas, gl, shaderProgram] = [r.canvas, r.gl, r.shaderProgram];
    vertices = [-0.5, 0.5, 0.0, 0, -0.5, -0.5, 0.0, 0, 0.5, -0.5, 0.0, 0, 0.5, 0.5, 0.0, 0];
    indices = [0, 1, 2, 2, 3, 0];
    geometry = new Geometry(r, vertices, indices);
    camera = new Camera(r, {
      position: [0.0, 0.0, -8.0]
    });
    app = new Application(r, geometry, camera);
    return app.run();
  };

  main();

}).call(this);
