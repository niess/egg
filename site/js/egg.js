// Generated by CoffeeScript 2.3.2
(function() {
  var Camera, Geometry, Renderer, main;

  Renderer = class Renderer {
    constructor(canvasId, ...shaderIds) {
      var canvas, getShaderById, gl, i, id, len, shader, shaderProgram;
      this.update = this.update.bind(this);
      canvas = document.querySelector(canvasId);
      if (!canvas) {
        throw `Could not find canvas with id = \`${id}\``;
      }
      gl = canvas.getContext("webgl");
      if (!gl) {
        throw `Could not initialise WebGL for canvas with id = \`${id}\``;
      }
      getShaderById = (function() {
        var types;
        types = {
          "x-shader/x-vertex": gl.VERTEX_SHADER,
          "x-shader/x-fragment": gl.FRAGMENT_SHADER
        };
        return function(id) {
          var element, error, shader, type, type_attr;
          element = document.getElementById(id);
          if (!element) {
            throw `could not load shader \`${id}\``;
          }
          type_attr = element.getAttribute("type");
          type = types[type_attr];
          if (types == null) {
            throw `unknown type \`${type_attr}\` for shader \`${id}\``;
          }
          shader = gl.createShader(type);
          gl.shaderSource(shader, element.text);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            error = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw `while compiling shader \`${id}\`: ${error}`;
          }
          return shader;
        };
      })();
      shaderProgram = gl.createProgram();
      for (i = 0, len = shaderIds.length; i < len; i++) {
        id = shaderIds[i];
        shader = getShaderById(id);
        gl.attachShader(shaderProgram, shader);
      }
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        throw "Could not link shaders";
      }
      gl.useProgram(shaderProgram);
      shaderProgram.location = {
        vertex: gl.getAttribLocation(shaderProgram, "vertex")
      };
      gl.clearColor(0.5, 0.5, 0.5, 0.9);
      gl.enable(gl.DEPTH_TEST);
      gl.viewport(0, 0, canvas.width, canvas.height);
      [this.canvas, this.gl, this.shaderProgram] = [canvas, gl, shaderProgram];
    }

    update(geometry) {
      var gl, indices;
      gl = this.gl;
      gl.clear(gl.COLOR_BUFFER_BIT);
      indices = geometry.buffers.indices;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);
      return gl.drawElements(gl.TRIANGLES, geometry.size, gl.UNSIGNED_SHORT, 0);
    }

  };

  Camera = class Camera {
    constructor(renderer, kwargs) {
      var aspect, canvas, far, fov, gl, near, position, rotation, shaderProgram;
      canvas = renderer.canvas;
      if (kwargs != null) {
        ({fov, aspect, near, far, position, rotation} = kwargs);
      }
      if (fov == null) {
        fov = 45 * Math.PI / 180;
      }
      if (aspect == null) {
        aspect = canvas.width / canvas.height;
      }
      if (near == null) {
        near = 0.1;
      }
      if (far == null) {
        far = 100;
      }
      this.projection = glMatrix.mat4.create();
      glMatrix.mat4.perspective(this.projection, fov, aspect, near, far);
      this.view = glMatrix.mat4.create();
      if (position != null) {
        this.translate(...position);
      }
      // Set the uniforms for the shader
      [gl, shaderProgram] = [renderer.gl, renderer.shaderProgram];
      gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "projection"), false, this.projection);
      gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, "view"), false, this.view);
    }

    translate(x, y, z) {
      return glMatrix.mat4.translate(this.view, this.view, [-x, -y, -z]);
    }

  };

  Geometry = class Geometry {
    constructor(renderer, vertices, indices) {
      var gl, indexBuffer, shaderProgram, vertexBuffer;
      [gl, shaderProgram] = [renderer.gl, renderer.shaderProgram];
      // Create and fill the vertex buffer
      vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.vertexAttribPointer(shaderProgram.location.vertex, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(shaderProgram.location.vertex);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      // Create and fill the index buffer
      indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      this.buffers = {
        vertices: vertexBuffer,
        indices: indexBuffer
      };
      this.size = indices.length;
    }

  };

  main = function() {
    var camera, canvas, geometry, gl, indices, r, shaderProgram, vertices;
    r = new Renderer("#glCanvas", "egg-vs", "egg-fs");
    [canvas, gl, shaderProgram] = [r.canvas, r.gl, r.shaderProgram];
    vertices = [-0.5, 0.5, 0.0, 0, -0.5, -0.5, 0.0, 0, 0.5, -0.5, 0.0, 0, 0.5, 0.5, 0.0, 0];
    indices = [0, 1, 2, 2, 3, 0];
    geometry = new Geometry(r, vertices, indices);
    camera = new Camera(r, {
      position: [0.0, 0.0, 8.0]
    });
    return r.update(geometry);
  };

  main();

}).call(this);
